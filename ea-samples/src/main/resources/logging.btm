RULE set up ea bbb
CLASS EscapeAnalysisIntraMethodBuilder
METHOD <init>
AT EXIT
BIND
  th = Thread.currentThread();
  element = $2.getCurrentElement();
  prefix = "(" + th.getName() + ") ";
IF TRUE
DO
  link(th, "logging.cg", $this.connectionGraph);
  link(th, "logging.name", element.toString());
  link(th, "logging.prefix", prefix);
  traceln(prefix + "EA: construct intra method analysis for " + element.toString());
ENDRULE

RULE instance field of
CLASS EscapeAnalysisIntraMethodBuilder
METHOD instanceFieldOf
AT ENTRY
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  prefix = linked(th, "logging.prefix");
IF
  $this.connectionGraph == cg
DO traceln(prefix.toString() + "EA: instanceFieldOf " + $1.toString())
ENDRULE

RULE handle reference
CLASS EscapeAnalysisIntraMethodBuilder
METHOD handleInstanceFieldOf
AT ENTRY
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  prefix = linked(th, "logging.prefix");
IF $this.connectionGraph == cg
DO traceln(prefix.toString() + "EA: handleInstanceFieldOf " + $1.toString() + " with target " + $3.toString())
ENDRULE

RULE store
CLASS EscapeAnalysisIntraMethodBuilder
METHOD store
AT ENTRY
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  prefix = linked(th, "logging.prefix");
IF $this.connectionGraph == cg
DO traceln(prefix.toString() + "EA: store " + $2.toString() + " into " + $1.toString())
ENDRULE

RULE call method
CLASS EscapeAnalysisIntraMethodBuilder
METHOD call
AT EXIT
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  prefix = linked(th, "logging.prefix");
IF $this.connectionGraph == cg
DO traceln(prefix.toString() + "EA: call " + $1.toString() + " with " + $2.toString() + " returns " + $!)
ENDRULE

RULE start method
CLASS EscapeAnalysisIntraMethodBuilder
METHOD startMethod
AT ENTRY
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  prefix = linked(th, "logging.prefix");
IF $this.connectionGraph == cg
DO traceln(prefix.toString() + "EA: start method " + $this.getCurrentElement().toString() + " with " + $1.toString())
ENDRULE

RULE return_
CLASS EscapeAnalysisIntraMethodBuilder
METHOD return_
AT ENTRY
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  prefix = linked(th, "logging.prefix");
IF $this.connectionGraph == cg
DO traceln(prefix.toString() + "EA: return_ " + $1.toString() + " from " + $this.getCurrentElement().toString())
ENDRULE

RULE finish
CLASS EscapeAnalysisIntraMethodBuilder
METHOD finish
AT ENTRY
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  prefix = linked(th, "logging.prefix");
IF $this.connectionGraph == cg
DO traceln(prefix.toString() + "EA: finish " + $this.getCurrentElement().toString())
ENDRULE

RULE set arg escape
CLASS ConnectionGraph
METHOD setEscapeValue
AT ENTRY
BIND
  th = Thread.currentThread();
  cg = linked(th, "logging.cg");
  name = linked(th, "logging.name");
  prefix = linked(th, "logging.prefix");
IF $this == cg
DO traceln(prefix.toString() + "EA: set escape value for " + $1.toString() + " in " + name + " to " + $2.toString())
ENDRULE

RULE call graph calls
CLASS EscapeAnalysisState
METHOD trackCall
AT ENTRY
BIND
  executable : org.qbicc.graph.Executable = $2.getValueHandle();
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: track call " + $1.toString() + " to " + executable.getExecutable().toString())
ENDRULE

RULE update connection graph
CLASS EscapeAnalysisInterMethodAnalysis
METHOD updateConnectionGraph
AT ENTRY
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: update connection graph for " + $1.toString())
ENDRULE

RULE find interface connection graph
CLASS EscapeAnalysisInterMethodAnalysis
METHOD findInterfaceConnectionGraph
AT ENTRY
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: find interface connection graph for " + $1.toString())
ENDRULE

RULE find interface implementors in type
CLASS EscapeAnalysisInterMethodAnalysis
METHOD findInterfaceImplementorsInType
AT ENTRY
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: find in type " + $2.getInternalName())
ENDRULE

RULE find interface implementors
CLASS EscapeAnalysisInterMethodAnalysis
METHOD findInterfaceImplementors
AT EXIT
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: implementors of interface method " + $1.toString() + " are: " + $!.toString())
ENDRULE

RULE update at method entry
CLASS ConnectionGraph
METHOD updateAtMethodEntry
AT ENTRY
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: update at method entry " + $this.toString())
ENDRULE

RULE update after invoking method
CLASS ConnectionGraph
METHOD updateAfterInvokingMethod
AT ENTRY
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: update " + $this.toString() + " after invoking " + $2.name)
ENDRULE

RULE update at method exit
CLASS ConnectionGraph
METHOD updateAtMethodExit
AT ENTRY
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: update at method exit " + $this.toString())
ENDRULE

RULE merge escape values
CLASS ConnectionGraph
METHOD mergeEscapeValues
AT EXIT
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ") EA: merge escape values of " + $this.escapeValues.toString() + " with " + $1.escapeValues.toString() + " returns " + $!.toString())
ENDRULE

RULE stack allocate
CLASS EscapeAnalysisOptimizeVisitor
METHOD stackAllocate
AT ENTRY
IF TRUE
DO traceln("(" + Thread.currentThread().getName() + ")" + " EA: New " + $1.type.toString() + " on " + $2.getCurrentElement() + " does not escape, so stack allocate it")
ENDRULE

#RULE register node
#CLASS ConnectionGraphDotVisitor
#METHOD register
#AT EXIT
#IF TRUE
#DO traceln("(" + Thread.currentThread().getName() + ") (" + $this.connectionGraph.name + ") register node " + $1.toString() + " returns " + $!)
#ENDRULE
